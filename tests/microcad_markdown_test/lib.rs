// Copyright © 2024-2026 The µcad authors <info@ucad.xyz>
// SPDX-License-Identifier: AGPL-3.0-or-later

//! Generate tests out of *Markdown* files which include µcad code
//!
//! Path will be scanned recursively for *Markdown* files (`*.md`).
//! Code must be marked by *Markdown* code markers (code type: `µcad`) with a test ID attached.
//! In case of a failing test `#fail` must be appended to the test ID.
//!
//! Relative path's of scanned folder names will be used to build a modules structure
//! in the resulting code.
//! If test IDs include `.` name will be split into several names which will be
//! used to crates sub modules.

use microcad_test_tools::{output::*, test_env::*};
use miette::{Context, IntoDiagnostic, Result};
use std::{io::Write, path::Path};

/// for debugging purpose
#[allow(unused)]
macro_rules! warning {
    ($($tokens: tt)*) => {
        // HINT: switch `note` -> `warning` to activate debug messages
        println!("cargo:note={}", format!($($tokens)*))
    }
}

/*#[test]
fn md_tests() {
    env_logger::init();

    println!("Generating Markdown Tests...");
    std::env::set_var("OUT_DIR", "../../target");

    generate("..", "microcad_markdown_test.rs", "../doc/test_list.md").unwrap();
}*/

/// Generate tests from the *Markdown* files which are within the given `path`
///
/// Path will be scanned recursively
pub fn generate(
    path: impl AsRef<Path>,
    out_file: impl AsRef<Path>,
    test_list_file: impl AsRef<Path>,
) -> Result<()> {
    use std::*;

    // get target path
    let out_dir = env::var("OUT_DIR").into_diagnostic()?;
    let dest_path = path::Path::new(&out_dir).join(out_file);
    // we will create a single output file whose content will be written into this variable first
    let mut code = String::from(
        r#"// This code was generated by microcad_markdown_test
// Copyright © 2024 The µcad authors <info@ucad.xyz>
// SPDX-License-Identifier: AGPL-3.0-or-later


"#,
    );

    // directories to exclude
    let exclude_dirs = ["target", "thirdparty"];

    let mut test_outputs = Vec::new();

    // read all *Markdown files and write result into `code`
    scan(
        &mut code,
        path.as_ref(),
        "md",
        &exclude_dirs,
        &mut test_outputs,
    )?;

    create_test_list(test_list_file, &test_outputs);

    // remove any previous banners
    remove_banners(path, &exclude_dirs, &test_outputs)?;

    fs::write(&dest_path, code)
        .into_diagnostic()
        .context(format!("cannot create file '{dest_path:?}'"))
}

fn create_test_list(path: impl AsRef<std::path::Path>, outputs: &[Output]) {
    let mut seen = std::collections::HashSet::new();
    for item in outputs.iter().map(|o| &o.name) {
        if !seen.insert(item) {
            panic!("doublet test name '{item}' in {:?}", path.as_ref())
        }
    }

    std::fs::File::create(path.as_ref())
        .expect("file access error")
        .write_all(make_test_list(&path, outputs).as_bytes())
        .expect("write error");
    // tell cargo to watch this file
    println!("cargo:rerun-if-changed={}", path.as_ref().display());
}

fn make_test_list(path: impl AsRef<std::path::Path>, tests: &[Output]) -> String {
    let count = tests.len();
    let mut result = format!(
        "# Test List

The following table lists all tests included in this documentation.

**{count}** tests have been evaluated with version **{version}** of microcad.

Click on the test names to jump to file with the test or click the buttons to get the logs.

| Result | Source | Name |
|-------:|--------|------|
",
        version = env!("CARGO_PKG_VERSION")
    );

    {
        let mut tests = tests.iter().collect::<Vec<_>>().clone();
        tests.sort();
        tests.iter().for_each(|test| {
            result.push_str(&test.table_row(path.as_ref().parent().expect("invalid path")));
        });
    }

    result
}

/// Remove all banners in `path` and exclude folders whose names are contained
/// in `exclude_dirs` from search.
fn remove_banners(
    path: impl AsRef<Path>,
    exclude_dirs: &[&str],
    exclude_outputs: &[Output],
) -> Result<()> {
    //warning!("remove_banners: {:?} {exclude_files:?}", path.as_ref());
    for entry in std::fs::read_dir(&path).into_diagnostic()?.flatten() {
        // get file type
        if let Ok(file_type) = entry.file_type() {
            // check if directory or file
            if file_type.is_dir()
                && !exclude_dirs.contains(&entry.file_name().to_string_lossy().to_string().as_str())
            {
                if entry.file_name() == ".test" {
                    clean_dir(entry.path(), exclude_outputs)?;
                } else {
                    remove_banners(entry.path(), exclude_dirs, exclude_outputs)?;
                }
            }
        }
    }

    Ok(())
}

/// Remove all files within `.test` directory
fn clean_dir(path: impl AsRef<Path>, exclude_files: &[Output]) -> Result<()> {
    warning!("remove banners in: {:?}", path.as_ref());

    // list all files within `.test` directory and remove them
    for entry in std::fs::read_dir(&path)
        .unwrap()
        .flatten()
        .filter(|entry| entry.file_type().unwrap().is_file())
    {
        if 0 == exclude_files
            .iter()
            .filter(|f| f.has_path(&entry.path()))
            .count()
        {
            // warning!("remove: {:?}", entry.path());
            std::fs::remove_file(entry.path()).into_diagnostic()?;
        }
    }
    Ok(())
}

/// scan folder
fn scan(
    output: &mut String,
    path: &Path,
    extension: &str,
    exclude_dirs: &[&str],
    test_outputs: &mut Vec<Output>,
) -> Result<bool> {
    // prepare return value
    let mut found = false;
    // read given directory
    for entry in std::fs::read_dir(path).into_diagnostic()?.flatten() {
        // get file type
        if let Ok(file_type) = entry.file_type() {
            let file_name = entry.file_name().into_string().unwrap();
            // check if directory or file
            if file_type.is_dir() && !exclude_dirs.contains(&file_name.as_str()) {
                let mut code = String::new();
                // scan deeper
                if scan(
                    &mut code,
                    &entry.path(),
                    extension,
                    exclude_dirs,
                    test_outputs,
                )? {
                    if let Some(name) = entry.path().file_stem() {
                        let name = name.to_str().unwrap();
                        output.push_str(&format!(
                            "#[allow(non_snake_case)]
                             mod r#{name} {{
                                 {code}
                             }}\n\n"
                        ))
                    } else {
                        output.push_str(&code);
                    }

                    // found something
                    found = true;
                }
            } else if file_type.is_file()
                && file_name.ends_with(&format!(".{extension}"))
                && !scan_for_tests(output, &entry.path(), test_outputs)?
            {
                // tell cargo to watch this file
                println!("cargo:rerun-if-changed={}", entry.path().display());
                // found something
                found = true;
            }
        }
    }

    Ok(found)
}

/// Read single *Markdown* file and collect included tests in `tree`.
///
/// Generates tree models if name can be split into several names which are separated by `.`.
fn scan_for_tests(
    output: &mut String,
    file_path: &Path,
    test_outputs: &mut Vec<Output>,
) -> Result<bool> {
    use regex::*;
    use std::fs::*;

    // `true`` if we didn't found anything
    let mut result = true;

    // load markdown file
    let md_content = read_to_string(file_path).into_diagnostic()?;

    // accumulate name and code while reading file
    let mut test_name = String::new();
    let mut test_code = String::new();

    let start = Regex::new(r#"```[mµ][Cc][Aa][Dd](,(?<name>[\.\(\)#_\w]+))?"#).expect("bad regex");
    let end = Regex::new(r#"```"#).expect("bad regex");

    let mut ignore = false;
    let mut start_no = 0;
    // read all lines in the file
    for (line_no, line) in md_content.lines().enumerate() {
        // ignore deeper markdown code
        if line.starts_with("````") {
            ignore = !ignore;
            warning!("ignoring: {ignore}");
        }

        if !ignore {
            // match code starting marker
            if let Some(start) = start.captures_iter(line).next() {
                if let Some(name) = start.name("name") {
                    // remember test name
                    test_name = name.as_str().to_string();
                    start_no = line_no + 2;
                    // clear code
                    test_code.clear();
                }
            } else if !test_name.is_empty() {
                // match code end marker
                if end.captures_iter(line).next().is_some() {
                    if let Some(mut env) = TestEnv::new(file_path, &test_name, &test_code, start_no)
                    {
                        let head = "// file: ";
                        let mut test_output = env.generate(output);
                        if let Some(first_line) =
                            test_code.lines().find(|line| line.starts_with(head))
                        {
                            if first_line.starts_with(head) {
                                let (_, filename) = first_line.split_at(head.len());
                                let filename = env.test_path().join(filename);
                                let mut file = std::fs::File::create(filename.clone())
                                    .expect("cannot create file");
                                file.write_all(test_code.as_bytes())
                                    .expect("cannot write file");
                                test_output.add_output(filename);
                            }
                        }
                        test_outputs.push(test_output);
                    }

                    // clear name to signal new test awaited
                    test_name.clear();

                    // found some test
                    result = false;
                } else {
                    // add line to code
                    test_code.push_str(line);
                    test_code.push('\n');
                }
            }
        }
    }
    Ok(result)
}
